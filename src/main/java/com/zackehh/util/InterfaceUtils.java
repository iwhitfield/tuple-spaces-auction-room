package com.zackehh.util;

import com.zackehh.auction.IWsBid;
import com.zackehh.auction.IWsLot;
import com.zackehh.auction.IWsUser;
import net.jini.space.JavaSpace;

import javax.swing.text.JTextComponent;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Vector;

public class InterfaceUtils {

    /**
     * Default constructor which should not be called. All method calls
     * should be called from a static context.
     */
    private InterfaceUtils(){
        throw new UnsupportedOperationException();
    }

    /**
     * Parse a text input as a Number. Should the input not be
     * a valid Number, set errorTextOut to display a parse error.
     *
     * @param  component    the component to retrieve text of
     * @return Number       a valid Number object
     */
    public static Number getTextAsNumber(JTextComponent component){
        try {
            String input = component.getText().replaceAll("^[^0-9|\\.|-]", "");
            return NumberFormat.getInstance().parse(input);
        } catch(ParseException e){
            return null;
        }
    }

    /**
     * Parse a Double to a currency formatted string.
     *
     * @param  value        the Double value to convert
     * @return Double       a valid currency string
     */
    public static String getDoubleAsCurrency(Double value){
        // Create enforcer
        DecimalFormat currencyEnforcer = new DecimalFormat("0.00");

        // If value is null, short circuit
        if(value == null){
            return null;
        }

        // Format currency
        String currency = currencyEnforcer.format(value);

        // Handle negative values
        if(currency.charAt(0) == '-'){
            return "-£" + currency.substring(1);
        } else {
            return "£" + currency;
        }

    }

    /**
     * Returns a List of bids associated with the passed in lot.
     * Converts the string history from inside the lot to gather
     * the bid IDs associated with the lot. It is here that
     * the logic for private bids takes place, with a user ID
     * replacement to "Anonymous Buyer" if the bid is private and
     * not created by the current user.
     *
     * @param  lot          the IWsLot to gather history for
     * @return ArrayList    the list of bids associated
     */
    public static ArrayList<IWsBid> getBidHistory(IWsLot lot) {
        JavaSpace space = SpaceUtils.getSpace();

        // Initialise a list to store history
        ArrayList<IWsBid> bidHistory = new ArrayList<IWsBid>();

        try {
            // Fetch the latest version of the lot
            IWsLot refreshedLot = (IWsLot) space.read(new IWsLot(lot.getId()), null, Constants.SPACE_TIMEOUT);

            // Get the history from the lot
            ArrayList<Integer> bids = refreshedLot.getHistory();

            // If no history, short circuit
            if(bids.size() == 0){
                return bidHistory;
            }

            // Add all bids by id
            for(Integer bidId : bids){
                // Lookup the bid with the given id
                IWsBid template = new IWsBid(bidId, null, lot.getId(), null, null);
                IWsBid bidItem = ((IWsBid) space.read(template, null, Constants.SPACE_TIMEOUT));

                // If the bid is anonymous, reset the user (locally)
                if(bidItem.isAnonymous(refreshedLot)) {
                    bidItem.setUser(new IWsUser("Anonymous Buyer"));
                }

                // Add the bid to the history list
                bidHistory.add(bidItem);
            }
        } catch(Exception e){
            e.printStackTrace();
        }

        // Sort bids by price, just in case order is incorrect
        Collections.sort(bidHistory, new Comparator<IWsBid>() {
            @Override
            public int compare(IWsBid bid1, IWsBid bid2) {
                return bid2.getPrice().compareTo(bid1.getPrice());
            }
        });

        return bidHistory;
    }

    /**
     * Returns a bid history generated by InterfaceUtils#getBidHistory
     * in the format of Vector<Vector<String>> so it can be passed in
     * to a table model and displayed more easily.
     *
     * @param  lot          the IWsLot to gather history for
     * @return Vector       a matrix of IWsBid values
     */
    public static Vector<Vector<String>> getVectorBidMatrix(IWsLot lot){
        // Get the list of historic bids
        ArrayList<IWsBid> bids = getBidHistory(lot);

        // Initialise empty Vector
        Vector<Vector<String>> values = new Vector<Vector<String>>();

        for(int iY = 0; iY < bids.size(); iY++){
            // Grab the bid at the index
            final IWsBid bid = bids.get(iY);

            // Add each bid as a vector
            values.add(iY, new Vector<String>(){{
                add(bid.getUser().getId());
                add(InterfaceUtils.getDoubleAsCurrency(bid.getPrice()));
            }});
        }

        return values;
    }

    /**
     * Returns a String converted to CamelCase when using
     * argument split as a delimiter for the split.
     *
     * @param  str          the string to convert
     * @param  split        the split delimiter
     * @return String       the camelCase string
     */
    public static String toCamelCase(String str, String split){
        // Convert to lower case and split on splitter
        String[] parts = str.toLowerCase().split(split);

        int i = 0;
        String camelCaseString = "";

        // For each part upper case the first char if needed
        for (String part : parts){
            if(i++ > 0) {
                camelCaseString +=
                        part.substring(0, 1).toUpperCase() +
                        part.substring(1).toLowerCase();
            } else {
                camelCaseString += part;
            }
        }

        // Return camelCase version only if string has a split
        return camelCaseString.length() == 0 || parts.length == 1 ? str : camelCaseString;
    }

}
